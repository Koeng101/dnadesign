// Code generated by command: go run asm.go -out svb_amd64.s -stubs stub_amd64.go. DO NOT EDIT.

// +build !noasm
// +build !appengine
// +build !gccgo

#include "textflag.h"

// func Uint32Decode128(masks []byte, data []byte, out []uint32)
// Requires: AVX, SSSE3
TEXT ·Uint32Decode128(SB), NOSPLIT, $0-72
	// shuffleTable = &ShuffleTable[256][16]
	LEAQ ·ShuffleTable+0(SB), AX
	MOVQ masks_base+0(FP), CX
	MOVQ masks_len+8(FP), DX
	MOVQ data_base+24(FP), BX
	MOVQ out_base+48(FP), BP
	XORQ SI, SI
	XORQ R9, R9
	XORQ R8, R8
	JMP  condition

increment:
	// i++
	LEAQ 1(SI), SI

condition:
	// i < len(masks)
	CMPQ SI, DX

	// goto done if i >= len(masks)
	JGE done

	// m = masks[i]
	MOVBQZX (CX)(SI*1), R9

	// lookup = &ShuffleTable[m][16]
	SHLQ $0x04, R9
	LEAQ (AX)(R9*1), DI
	MOVQ SI, R10

	// step = i * 4 (4 integers)
	SHLQ    $0x02, R10
	VMOVDQU (BX)(R8*1), X0
	PSHUFB  (DI), X0
	VMOVDQU X0, (BP)(R10*4)

	// m >>= 6, note: m << 4 earlier
	SHRL $0x0a, R9

	// m += 12
	ADDL $0x0c, R9

	// lookup = ShuffleTable[m][12 + m >> 6]
	MOVBQZX (DI)(R9*1), DI

	// offset += ShuffleTable[m][12 + m >> 6] + 1
	LEAQ 1(R8)(DI*1), R8
	JMP  increment

done:
	RET

// func Uint32Decode256(masks []byte, data []byte, out []uint32)
// Requires: AVX, AVX2, SSSE3
TEXT ·Uint32Decode256(SB), NOSPLIT, $0-72
	// shuffleTable = &ShuffleTable[256][16]
	LEAQ ·ShuffleTable+0(SB), AX
	MOVQ masks_base+0(FP), CX
	MOVQ masks_len+8(FP), DX
	MOVQ data_base+24(FP), BX
	MOVQ out_base+48(FP), BP
	XORQ SI, SI
	XORQ R9, R9
	XORQ R8, R8
	JMP  condition_0

increment_0:
	// i += 2
	LEAQ 2(SI), SI

condition_0:
	MOVQ DX, DI
	SUBQ SI, DI
	CMPQ DI, $0x02

	// goto done if i >= len(masks)
	JLT  done_0
	MOVQ SI, R10

	// step = i * 4 (4 integers)
	SHLQ $0x02, R10

	// 0th DOUBLE QWORD
	// m = masks[i]
	MOVBQZX (CX)(SI*1), R9

	// lookup = &ShuffleTable[m][16]
	SHLQ $0x04, R9
	LEAQ (AX)(R9*1), DI

	// move 16 bytes from ShuffleTable[masks[0]] to 0 double qword
	VINSERTF128 $0x00, (DI), Y0, Y0

	// move 16 bytes from data[offset] to 0 double qword
	VINSERTF128 $0x00, (BX)(R8*1), Y1, Y1

	// m >>= 6, note: m << 4 earlier
	SHRL $0x0a, R9

	// m += 12
	ADDL $0x0c, R9

	// lookup = ShuffleTable[m][12 + m >> 6]
	MOVBQZX (DI)(R9*1), DI

	// offset += ShuffleTable[m][12 + m >> 6] + 1
	LEAQ 1(R8)(DI*1), R8

	// 1th DOUBLE QWORD
	// m = masks[i]
	MOVBQZX 1(CX)(SI*1), R9

	// lookup = &ShuffleTable[m][16]
	SHLQ $0x04, R9
	LEAQ (AX)(R9*1), DI

	// move 16 bytes from ShuffleTable[masks[1]] to 1 double qword
	VINSERTF128 $0x01, (DI), Y0, Y0

	// move 16 bytes from data[offset] to 1 double qword
	VINSERTF128 $0x01, (BX)(R8*1), Y1, Y1

	// m >>= 6, note: m << 4 earlier
	SHRL $0x0a, R9

	// m += 12
	ADDL $0x0c, R9

	// lookup = ShuffleTable[m][12 + m >> 6]
	MOVBQZX (DI)(R9*1), DI

	// offset += ShuffleTable[m][12 + m >> 6] + 1
	LEAQ 1(R8)(DI*1), R8

	// shuffle 8 uint32
	VPSHUFB Y0, Y1, Y2

	// move 8 uint32 to out
	VMOVDQU Y2, (BP)(R10*4)
	JMP     increment_0

done_0:
	JMP condition_1

increment_1:
	// i++
	LEAQ 1(SI), SI

condition_1:
	// i < len(masks)
	CMPQ SI, DX

	// goto done if i >= len(masks)
	JGE done_1

	// m = masks[i]
	MOVBQZX (CX)(SI*1), R9

	// lookup = &ShuffleTable[m][16]
	SHLQ $0x04, R9
	LEAQ (AX)(R9*1), DI
	MOVQ SI, R10

	// step = i * 4 (4 integers)
	SHLQ    $0x02, R10
	VMOVDQU (BX)(R8*1), X0
	PSHUFB  (DI), X0
	VMOVDQU X0, (BP)(R10*4)

	// m >>= 6, note: m << 4 earlier
	SHRL $0x0a, R9

	// m += 12
	ADDL $0x0c, R9

	// lookup = ShuffleTable[m][12 + m >> 6]
	MOVBQZX (DI)(R9*1), DI

	// offset += ShuffleTable[m][12 + m >> 6] + 1
	LEAQ 1(R8)(DI*1), R8
	JMP  increment_1

done_1:
	RET

// func Uint32Decode512(masks []byte, data []byte, out []uint32)
// Requires: AVX, SSSE3
TEXT ·Uint32Decode512(SB), NOSPLIT, $0-72
	// shuffleTable = &ShuffleTable[256][16]
	LEAQ ·ShuffleTable+0(SB), DX
	MOVQ masks_base+0(FP), AX
	MOVQ masks_len+8(FP), BX
	MOVQ data_base+24(FP), SI
	MOVQ out_base+48(FP), DI
	XORQ R10, R10
	XORQ R13, R13
	XORQ R12, R12
	JMP  condition_0

increment_0:
	// i += 4
	LEAQ 4(R10), R10

condition_0:
	MOVQ BX, CX
	SUBQ R10, CX
	CMPQ CX, $0x04

	// goto done if i >= len(masks)
	JLT  done_0
	MOVQ R10, R8

	// step = i * 4 (4 integers)
	SHLQ $0x02, R8

	// init R9W expand mask 00000011
	MOVW $0x0003, R9

	// 0th DOUBLE QWORD
	// m = masks[i]
	MOVBQZX (AX)(R10*1), R13

	// lookup = &ShuffleTable[m][16]
	SHLQ $0x04, R13
	LEAQ (DX)(R13*1), R11

	// AVX512, K1 = 00000011
	KMOVW R9, K1
	// AVX512, Move data[offset:] to Z0 with mask 00000011
	VPEXPANDQ (SI)(R12*1), K1, Z0
	// AVX512, Move ShuffleTable[masks[0]] to Z1 with mask 00000011  
	VPEXPANDQ (R11), K1, Z1
	// m >>= 6, note: m << 4 earlier
	SHRL $0x0a, R13

	// m += 12
	ADDL $0x0c, R13

	// lookup = ShuffleTable[m][12 + m >> 6]
	MOVBQZX (R11)(R13*1), R11

	// offset += ShuffleTable[m][12 + m >> 6] + 1
	LEAQ 1(R12)(R11*1), R12

	// 1th DOUBLE QWORD
	// expand mask R9 << 2, 00001100
	SHLW $0x02, R9

	// m = masks[i]
	MOVBQZX 1(AX)(R10*1), R13

	// lookup = &ShuffleTable[m][16]
	SHLQ $0x04, R13
	LEAQ (DX)(R13*1), R11

	// AVX512, K1 = 00001100
	KMOVW R9, K1
	// AVX512, Move data[offset:] to Z0 with mask 00001100
	VPEXPANDQ (SI)(R12*1), K1, Z0
	// AVX512, Move ShuffleTable[masks[1]] to Z1 with mask 00001100  
	VPEXPANDQ (R11), K1, Z1
	// m >>= 6, note: m << 4 earlier
	SHRL $0x0a, R13

	// m += 12
	ADDL $0x0c, R13

	// lookup = ShuffleTable[m][12 + m >> 6]
	MOVBQZX (R11)(R13*1), R11

	// offset += ShuffleTable[m][12 + m >> 6] + 1
	LEAQ 1(R12)(R11*1), R12

	// 2th DOUBLE QWORD
	// expand mask R9 << 2, 00110000
	SHLW $0x02, R9

	// m = masks[i]
	MOVBQZX 2(AX)(R10*1), R13

	// lookup = &ShuffleTable[m][16]
	SHLQ $0x04, R13
	LEAQ (DX)(R13*1), R11

	// AVX512, K1 = 00110000
	KMOVW R9, K1
	// AVX512, Move data[offset:] to Z0 with mask 00110000
	VPEXPANDQ (SI)(R12*1), K1, Z0
	// AVX512, Move ShuffleTable[masks[2]] to Z1 with mask 00110000  
	VPEXPANDQ (R11), K1, Z1
	// m >>= 6, note: m << 4 earlier
	SHRL $0x0a, R13

	// m += 12
	ADDL $0x0c, R13

	// lookup = ShuffleTable[m][12 + m >> 6]
	MOVBQZX (R11)(R13*1), R11

	// offset += ShuffleTable[m][12 + m >> 6] + 1
	LEAQ 1(R12)(R11*1), R12

	// 3th DOUBLE QWORD
	// expand mask R9 << 2, 11000000
	SHLW $0x02, R9

	// m = masks[i]
	MOVBQZX 3(AX)(R10*1), R13

	// lookup = &ShuffleTable[m][16]
	SHLQ $0x04, R13
	LEAQ (DX)(R13*1), R11

	// AVX512, K1 = 11000000
	KMOVW R9, K1
	// AVX512, Move data[offset:] to Z0 with mask 11000000
	VPEXPANDQ (SI)(R12*1), K1, Z0
	// AVX512, Move ShuffleTable[masks[3]] to Z1 with mask 11000000  
	VPEXPANDQ (R11), K1, Z1
	// m >>= 6, note: m << 4 earlier
	SHRL $0x0a, R13

	// m += 12
	ADDL $0x0c, R13

	// lookup = ShuffleTable[m][12 + m >> 6]
	MOVBQZX (R11)(R13*1), R11

	// offset += ShuffleTable[m][12 + m >> 6] + 1
	LEAQ 1(R12)(R11*1), R12

	// AVX512, shuffle 16 uint32
	VPSHUFB Z1, Z0, Z2
	// AVX512, Copy 16 uint32 to out
	VMOVDQU8 Z2, (DI)(R8*4)
	JMP increment_0

done_0:
	JMP condition_1

increment_1:
	// i++
	LEAQ 1(R10), R10

condition_1:
	// i < len(masks)
	CMPQ R10, BX

	// goto done if i >= len(masks)
	JGE done_1

	// m = masks[i]
	MOVBQZX (AX)(R10*1), R13

	// lookup = &ShuffleTable[m][16]
	SHLQ $0x04, R13
	LEAQ (DX)(R13*1), R11
	MOVQ R10, CX

	// step = i * 4 (4 integers)
	SHLQ    $0x02, CX
	VMOVDQU (SI)(R12*1), X0
	PSHUFB  (R11), X0
	VMOVDQU X0, (DI)(CX*4)

	// m >>= 6, note: m << 4 earlier
	SHRL $0x0a, R13

	// m += 12
	ADDL $0x0c, R13

	// lookup = ShuffleTable[m][12 + m >> 6]
	MOVBQZX (R11)(R13*1), R11

	// offset += ShuffleTable[m][12 + m >> 6] + 1
	LEAQ 1(R12)(R11*1), R12
	JMP  increment_1

done_1:
	RET
